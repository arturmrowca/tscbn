import pandas as pd

from _include.m_utils.adtree import ADTree
from general.base import Base

import warnings
warnings.filterwarnings("ignore")

class PrefixStructureDiscoverer(Base):
    """
    Interface defining structure discoverers.
    """

    def __init__(self, use_ADtree=False, fill_missing_values=False):
        """
        :param use_ADtree: if set to True, then an ADtree will be used instead of a pandas dataframe
            Only working for TreeDiscoverers and AStarDiscoverer at the moment!!!
        :param fill_missing_values: if set to True, then missing values are handled as an extra value
        """
        super(PrefixStructureDiscoverer, self).__init__(visual=True)
        self.use_ADtree = use_ADtree
        self.fill_missing_values = fill_missing_values
        self.data = None

    def discover_structure(self, sequences):
        """
        This approach discovers the structure of a TSCBN.
        :param sequences: input sequences
        """
        raise NotImplementedError("discover_structure() not implemented in class %s" % str(__class__))

    def create_ordered_event_sequences(self, sequences):
        """
        Takes the sequences as generated by the TSCBN structure generator and creates one ordered event sequence (one
        time only the signal names, the second time with value and timestamp) per sequence.
        Example for a ordered event sequence: <(V0, o0_1, 0.0), (V2, o2_0, 0.0), (V1, o1_0, 0.0), (V0, o0_0, 5.3)>
        Example without value and timestamp: <V0, V2, V1, V0>
        Returns a mapping from the event sequences with value and timestamp to the ones without value and timestamp and
        a list of event sequences without value (necessary to correctly determine the frequencies).
        :param sequences: input sequences
        :return event_sequence_map: Map from event sequences with value and timestamp to event sequences
            without value and timestamp. Later in the algorithm, this map is used to correctly number the events.
        :return event_sequences: event sequences without value and timestamp
        :return extendend_event_sequences: event sequences with value and timestamp
        """
        event_sequence_map = {}  # surjective mapping from sequences with values to sequences without values
        event_sequences = []
        extendend_event_sequences = []
        for sequence in sequences:
            event_sequence = []
            event_sequence_with_values = []
            signal_event_number_dict = {}  # remember number of already added events
            number_of_events = 0  # total number of events over all signals
            for signal in sequence:
                signal_event_number_dict.update({signal: 0})
                number_of_events += len(sequence.get(signal))
            for _ in range(number_of_events):
                next_event = None  # next event to add the event sequence, determined by "smallest" timestamp
                next_signal = None  # remember signal next_event belongs to
                for signal in sequence:
                    event_number = signal_event_number_dict.get(signal)
                    if event_number >= len(sequence.get(signal)):
                        continue
                    event = sequence.get(signal)[event_number]
                    # Assumption: Initial interval of all signals starts at timestamp 0.
                    assert event_number != 0 or event[1] == 0, 'Initial interval does not start at timestamp 0'
                    if not next_event or event[1] < next_event[1]:  # check if timestamp is "smaller"
                        next_event = event
                        next_signal = signal
                    pass
                event_number = signal_event_number_dict.get(next_signal)
                event_number += 1
                signal_event_number_dict.update({next_signal: event_number})
                event_sequence.append(next_signal)  # append the signal that belongs to next_event
                event_sequence_with_values.append(
                    (next_signal, next_event[0], next_event[1]))  # append event with smallest timestamp
            event_sequence_map.update({tuple(event_sequence_with_values): event_sequence})
            event_sequences.append(event_sequence)
            extendend_event_sequences.append(event_sequence_with_values)
        return event_sequence_map, event_sequences, extendend_event_sequences

    def get_datastructure(self, sequences):
        if self.use_ADtree:
            if not self.fill_missing_values:
                print('ADtree can only be used with missing values as extra value.')
                print('Parameter fill_missing_values was set to True.')
                self.fill_missing_values = True
            return self._create_adtree(sequences)
        return self._create_pandas_dataframe(sequences)

    def _create_adtree(self, sequences):
        """
        This method creates the ADtree. It is used to efficiently answer queries about how many times several
        combinations of signal values occurred during the structure discovery. This approach is faster than using
        a pandas dataframe. However, missing values have to be treated as extra value.
        :param sequences: extendend and numbered event sequences
        :return: adtree: ADtree
        """
        signals = set()
        signal_value_dicts = []
        for sequence in sequences:
            signal_value_dict = dict(sequence)
            signals |= set(signal_value_dict.keys())
            signal_value_dicts.append(signal_value_dict)
        return ADTree(signals, signal_value_dicts)

    def _create_pandas_dataframe(self, sequences):
        """
        This method creates a pandas dataframe. It is used to efficiently answer queries about how many times several
        combinations of signal values occurred during the structure discovery. The usage of the pandas dataframe
        instead of ADtree allows using the pgmpy structure scores and structure discoverers.
        :param sequences: extendend and numbered event sequences
        :return: adtree: pandas dataframe
        """
        signals = set()
        signal_value_dicts = []
        for sequence in sequences:
            signal_value_dict = dict(sequence)
            signals |= set(signal_value_dict.keys())
            signal_value_dicts.append(signal_value_dict)
        df = pd.DataFrame.from_records(signal_value_dicts)
        if self.fill_missing_values:
            df = df.fillna('MISSING_VALUE')

        # fill _0 entries with prev
        for c in df.columns:
            if not str.endswith(c, "_0"):continue
            prev_c = c[:-2] + "_1"
            if prev_c in df.columns:
                df[c] = df[c].combine_first(df[prev_c])

        # fill with last valid state e.g. S_1 replaced with S_0
        # ADDED BY ARTUR
        prev_c = None
        for c in df.columns:
            if prev_c is not None:
                df[c] = df[c].combine_first(df[prev_c])
            prev_c = c



        return df
